webpackHotUpdate("background",{

/***/ "./src/js/background.js":
/*!******************************!*\
  !*** ./src/js/background.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* global chrome*/\r\nlet video_url;//create to change the url of video snippet by ZZL\r\nlet behaviorTypes = [\"copy\", \"highlight\", \"video_snippet\", \"stay\", \"screenshot\"];\r\n//The characters that have associated meanings in xml of suggestions that\r\n//need to be replaced. The replacement characters are contained as values\r\n//to the keys.\r\nlet xmlChars = {\"&\": \"&amp;\"};\r\n\r\n__webpack_require__(/*! downloadjs */ \"./node_modules/downloadjs/download.js\");\r\n\r\nfunction isValidUrl(text) {\r\n    const valid = /((https?):\\/\\/)?(([w|W]{3}\\.)+)?[a-zA-Z0-9\\-\\.]{3,}\\.[a-zA-Z]{2,}(\\.[a-zA-Z]{2,})?/;\r\n    return valid.test(text);\r\n}\r\n\r\n\r\nfunction getRootUrl(rUrl){\r\n    if(rUrl.includes(\"&feature=youtu.be&t=\")){\r\n        rUrl=rUrl.split(\"&feature=youtu.be&t=\")[0];\r\n    }\r\n\r\n    if(rUrl.includes(\"#\")){\r\n        rUrl=rUrl.split(\"#\")[0];\r\n    }\r\n    return rUrl;\r\n}\r\n/**\r\n * A list of suggestions with common fields \"url\", \"title\", and \"query\". Each\r\n * suggestion corresponds to one past behavior of the user that is prompted by\r\n * the present text input given by the user in the omnibox.\r\n *\r\n * The matching mechanism is defined in the js/background.behaviorMatchesInput\r\n * method, which offers specific matching other than that of title and past\r\n * queries.\r\n *\r\n * Once a behavior matches the current input, js/background.storeSuggestionSnippet\r\n * function will be invoked to properly store this suggestion. A prototype holder\r\n * that contains the basic entries--url, title, query--will be passed in as a\r\n * parameter in case this information is necessary for specific storage. The storage\r\n * of this particular suggestion-behavior must also fill the \"content\" field of\r\n * the snippet. The processing is done by the modification of the passed in\r\n * prototype snippet, as aforementioned.\r\n *\r\n * Succeeding this, the suggestion snippet, the holder of the relevant information\r\n * of the past behavior to be prompted as a suggestion in the omnibox is stored\r\n * in this container, which will modified each time the input changes.\r\n *\r\n * As the selection of any suggestion, or in general the ascertainment of an\r\n * input in the omnibox must supercede some change in input, which triggers the\r\n * proper processing and population of this holder, all the behaviors that can\r\n * elicit a special direction, i.e. to a specific site, is properly stored in\r\n * this holder before js/background.acceptInput is invoked, which checks if\r\n * the input matches any suggestion in this container.\r\n */\r\nlet suggestionHolder;\r\nchrome.omnibox.onInputChanged.addListener(omniboxHandler);\r\nchrome.omnibox.onInputEntered.addListener(acceptInput);\r\nchrome.runtime.onMessage.addListener(handleMessage);\r\nchrome.runtime.onInstalled.addListener(function () {\r\n    chrome.storage.local.clear(function () {\r\n        const error = chrome.runtime.lastError;\r\n        if (error) {\r\n            console.error(error);\r\n        }\r\n    });\r\n});\r\n\r\n\r\n// When a tab just got created.\r\nchrome.tabs.onCreated.addListener(function(tab){\r\n    let toSave = {};\r\n    toSave[tab.id.toString()] = [];\r\n    console.log(\"initializing .. for tab \" + tab.id.toString());\r\n    chrome.storage.local.set(toSave);\r\n});\r\n\r\n/**\r\n * When there is a changed url for some tab,\r\n * 1) fetch the the original query words for the url, assuming the url is redirected\r\n * from a previous search result page in the same tab\r\n * 2) save the url visit record - if no visit in the past, create a entry, if there is, update the visit time\r\n * 3) save the query to the record.\r\n * 4ï¼‰let the content script know this url change, to update UI (draw markers, highlight texts, scroll, etc.)\r\n * 5) save this url history to tab.\r\n */\r\nchrome.tabs.onUpdated.addListener(function(tabId, changeInfo, tab) {\r\n    let tabUrl = getRootUrl(tab.url);\r\n    if (changeInfo.status === \"complete\" && isValidUrl(tabUrl)){\r\n        console.log(\"new url detected:\" + tabUrl +\" for tab \" + tabId);\r\n        let query = null;\r\n        //Look up url history for the current tab.\r\n        chrome.storage.local.get({[tabId.toString()]:[]}, function (item) {\r\n            let pastUrls = item[tabId.toString()];\r\n            // Fetch query from the url history of the current tab\r\n            if (pastUrls.length !== 0)\r\n            {\r\n                let i = pastUrls.length;\r\n                //Try get the most recent query.\r\n                while(--i>=0)\r\n                {\r\n                    try\r\n                    {\r\n                        //Attempt to extract query.\r\n                        query = extractQueryFromUrl(pastUrls[i]);\r\n                    }\r\n                    catch(exc)\r\n                    {\r\n                        //Skip.\r\n                        continue;\r\n                    }\r\n                    //Query extracted must be a string.\r\n                    if(query !== null && typeof query === \"string\")\r\n                        break;\r\n                }\r\n            }\r\n            //Update the current url to the url's behavior item map, if there isn't\r\n            //one yet, create it.\r\n            chrome.storage.local.get(tabUrl, function (urlEntry) {\r\n                //If this url has not been previously stored.\r\n                //merge the behavior of video and stay\r\n                let videoSnippet={};\r\n                let rightPosition=null;\r\n                if(!urlEntry[tabUrl])\r\n                {\r\n\r\n                    console.log(\"Url of this tab has not been previously stored!\", urlEntry);\r\n                    saveUrlInfo(tabUrl, {visit:[{visitTime: new Date(), query: query}],\r\n                        title: tab.title})\r\n                }\r\n                else\r\n                {\r\n                    console.log(\"Url previously visited!\", urlEntry);\r\n                    //The previous behavioral information garnered.\r\n                    let behavior = urlEntry[tabUrl];\r\n                    console.log(\"Behavior \", behavior);\r\n                    if (behavior) {\r\n                        if (behavior[\"video_snippet\"]) {\r\n                            videoSnippet = getMostValuableVideo(behavior[\"video_snippet\"]);\r\n                            console.log(videoSnippet);\r\n                        }\r\n                        if (behavior[\"stay\"]) {\r\n                            rightPosition = selectMostValuableStay(behavior[\"stay\"]);\r\n                            console.log(rightPosition);\r\n                        }\r\n                    }\r\n                    chrome.tabs.sendMessage(tabId, {\r\n                        url: tabUrl,\r\n                        \"type\":\"new_url\",\r\n                        \"video\": videoSnippet,\r\n                        \"position\": rightPosition\r\n                    }, function (response) {});\r\n                    //Add the current time and associated query to this url.\r\n                    let visits = behavior[\"visit\"];\r\n                    visits.push({visitTime: new Date(), query: query});\r\n                    saveUrlInfo(tabUrl, behavior)\r\n                }\r\n            });\r\n            //chrome.tabs.sendMessage(tabId, {url: tab.url}, function(response) {});\r\n            pastUrls.push(tabUrl);\r\n            saveUrlsToTab(pastUrls, tabId);\r\n        });\r\n    }\r\n});\r\n\r\n/**\r\n * Compare if two objects have identical fields and identical corresponding values.\r\n * The field \"time\" is not compared.\r\n * At present, comparing two behaviors is restricted to their actual information,\r\n * so if the difference is only in event_type, like \"copy\" and \"highlight\", while\r\n * their content object is the same, the result of comparison will be true.\r\n * @param obj1\r\n * @param obj2\r\n * @returns {boolean}\r\n */\r\nfunction compare(obj1, obj2)\r\n{\r\n    //Fields of both objects\r\n    let keys1 = Object.keys(obj1);\r\n    let keys2 = Object.keys(obj2);\r\n    //Sort the arrays for comparison.\r\n    keys1.sort();\r\n    keys2.sort();\r\n    console.log(\"keys \", keys1, keys2);\r\n    //If the two objects no not even have the same number of keys.\r\n    if(keys1.length !== keys2.length)\r\n        return false;\r\n    //Compare per field; spare the \"time\" field.\r\n    for(let index in keys1)\r\n    {\r\n        console.log(keys1[index], keys2[index], obj1[keys1[index], obj2[keys2[index]]]);\r\n        //If the field name is not identical.\r\n        if(keys1[index] !== keys2[index])\r\n            return false;\r\n        //If the value is not. Spare \"time\".\r\n        else if(keys1[index] !== \"time\" && obj1[keys1[index]] !== obj2[keys1[index]])\r\n            return false;\r\n    }\r\n    return true;\r\n}\r\n\r\n/**\r\n * Extract query given a url\r\n * TODO: support more url pattern to extract queries\r\n * @param url\r\n * @returns {*} the extracted query\r\n */\r\nfunction extractQueryFromUrl(url){\r\n    if (url.includes(\"google.com\")) {\r\n        const regex = /(?<=q=).*?(?=&)/s;\r\n        if (url.match(regex) !== null) {\r\n            return url.match(regex)[0].replace(/\\+/g, ' ');\r\n        }\r\n    }\r\n    if(url.includes(\".amazon.com\")){\r\n        const regex = /(?<=k=).*?(?=&)/s;\r\n        if (url.match(regex) !== null) {\r\n            return url.match(regex)[0].replace(/\\+/g, ' ');\r\n        }\r\n    }\r\n    if(url.includes(\".yelp.com\")){\r\n        const regex = /(?<=find_desc=).*?(?=&)/s;\r\n        if (url.match(regex) !== null) {\r\n            return url.match(regex)[0].replace(/\\+/g, ' ');\r\n        }\r\n    }\r\n    if(url.includes(\".linkedin.com\")){\r\n        const regex = /(?<=keywords=).*?(?=&)/s;\r\n        if (url.match(regex) !== null) {\r\n            return url.match(regex)[0].replace(/\\+/g, ' ');\r\n        }\r\n    }\r\n    if(url.includes(\".youtube.com\")){\r\n        const regex = /search_query=(.*)/;\r\n        if (url.match(regex)[1]!== null) {\r\n            return url.match(regex)[1];\r\n        }\r\n    }\r\n    if(url.includes(\".github.com\"||false||false||false)){\r\n        const regex = /q=(.*)/;\r\n        if (url.match(regex)[1]!== null) {\r\n            return url.match(regex)[1];\r\n        }\r\n    }\r\n    if(url.includes(\".wikipedia.org\")){\r\n        const regex = /wiki\\/(.*)/;\r\n        if (url.match(regex)[1]!== null) {\r\n            return url.match(regex)[1];\r\n        }\r\n    }\r\n    return null;\r\n}\r\n\r\n/**\r\n * Initializes or modifies the namespace for an url of its corresponding visit\r\n * information, which is an array of objects with keys \"visitTime\", and \"query\";\r\n * the latter may be null. This method is invoked when a tab is newly loaded.\r\n * The info parameter must be the entire map of behavioral information associated\r\n * with this url.\r\n * @param url The url whose corresponding behavioral information is to be modified.\r\n * @param info The entire map of behavioral information associated.\r\n */\r\nfunction saveUrlInfo(url, info)\r\n{\r\n    chrome.storage.local.set({[url]: info});\r\n}\r\n\r\n/**\r\n * Save a list of url as history for a tab\r\n * TODO: derek - add visit time information for each url.\r\n * @param urls\r\n * @param tabId\r\n */\r\nfunction saveUrlsToTab(urls, tabId){\r\n    console.log(\"save urls to tab \"+ tabId);\r\n    let toSave = {};\r\n    toSave[tabId.toString()] =  urls;\r\n    chrome.storage.local.set(toSave);\r\n}\r\n\r\n/**\r\n *\r\n * @param str\r\n * @param coords\r\n * @param callback\r\n */\r\nfunction cropData(str, coords, callback) {\r\n    let img = new Image();\r\n\r\n    img.onload = function() {\r\n        let canvas = document.createElement('canvas');\r\n        canvas.width = coords.w;\r\n        canvas.height = coords.h;\r\n\r\n        canvas.getContext('2d').drawImage(img, coords.x*window.devicePixelRatio, coords.y*window.devicePixelRatio, coords.w*window.devicePixelRatio, coords.h*window.devicePixelRatio, 0, 0, coords.w, coords.h);\r\n\r\n        callback({dataUri: canvas.toDataURL()});\r\n    };\r\n\r\n    img.src = str;\r\n}\r\n\r\n\r\n/**\r\n *\r\n * @param _screenshotObj\r\n */\r\nfunction capture(_screenshotObj) {\r\n    chrome.tabs.captureVisibleTab(null, {format: \"png\"}, function(data) {\r\n\r\n        cropData(data, _screenshotObj.coordinates, function(data) {\r\n            download(data.dataUri, _screenshotObj.filename, \"image/plain\");\r\n        });\r\n    });\r\n}\r\n\r\n\r\n/**\r\n * Update, or add, a behavior item on the given web page. Each url corresponds with\r\n * a map that contains different behavior codes as keys and an array that contains\r\n * all behavioral information of this type of behavior. For certain information, as\r\n * title, which does not really account for a behavior that can occur more than once,\r\n * their corresponding value may be a single value.\r\n * @param url The url associated with this information.\r\n * @param behaviorType The type of behavior, as delineated in the behavior code container.\r\n * @param behavior The actual bundle of behavioral information to be stored.\r\n */\r\nfunction update(url, behaviorType, behavior)\r\n{\r\n    //If no previous storage of behavior exists under this url, result would be {}.\r\n    chrome.storage.local.get(url, function (result)\r\n    {\r\n        // If there are no existing behaviors stored yet to this url,\r\n        // provide a container.\r\n        let existingBehaviors;\r\n        if(!result[url])\r\n            existingBehaviors = {};\r\n        else\r\n            existingBehaviors = result[url];\r\n        //All previous behaviors of this category.\r\n        let bhvs;\r\n        //Whether the current behavior is a duplicate in content of one recorded\r\n        //before.\r\n        let isDuplicate = false;\r\n        // Append the new behavior to the end of the list of this type of behavior\r\n        if(!result[url] || !existingBehaviors[behaviorType])\r\n            existingBehaviors[behaviorType] = [];\r\n        else\r\n        {\r\n            bhvs = existingBehaviors[behaviorType];\r\n            //Check if a duplicate behavior of a different access time is encountered.\r\n            for(let index in bhvs)\r\n            {\r\n                if(compare(bhvs[index], behavior))\r\n                {\r\n                    if(isDuplicate)\r\n                        bhvs[index].time.push(behavior.time[0]);\r\n                    isDuplicate = true;\r\n                }\r\n            }\r\n        }\r\n        bhvs = existingBehaviors[behaviorType];\r\n        if(!isDuplicate)\r\n        //Append this behavior as new behavior if none with the same content\r\n        //is found.\r\n            bhvs.push(behavior);\r\n        //The url-associated behavior record.\r\n        let toSave = {};\r\n        toSave[url] = existingBehaviors;\r\n        console.log(existingBehaviors);\r\n        console.log(\"Behavior Stored \", toSave);\r\n        chrome.storage.local.set(toSave);\r\n    });\r\n}\r\n\r\n/**\r\n * Selecting a most probable stay users would like to revisit\r\n * TODO: @ZZL - Consider stay frequency\r\n * @param array\r\n * @returns {*}\r\n */\r\n//update consider stay frequency\r\nfunction selectMaxPosition(array){\r\n    let maxPosition=0;\r\n    for (let i = 0; i <= array.length - 1; i++) {\r\n        if (array[i].position > maxPosition) {\r\n            maxPosition = array[i].position;\r\n        }\r\n    }\r\n    return maxPosition;\r\n}\r\n//Window maximization about 1000 a page,divide by 500 a part\r\nfunction selectMostValuableStay(array) {\r\n    let sumDuration = [];\r\n    let stayPosition=[];\r\n    let scrollTo;\r\n    let maxDuration=0;\r\n    let k = Math.ceil(selectMaxPosition(array)/ 500);\r\n    for (k; k >=0; k--) {\r\n        sumDuration[k]=0;\r\n        stayPosition[k]=0;\r\n        for (let i = 0; i <= array.length - 1; i++) {\r\n            if (array[i].position > 500 * (k - 1) && array[i].position <= 500 * k) {\r\n                sumDuration[k] = sumDuration[k] + array[i].duration;\r\n                stayPosition[k] = (array[i].position + stayPosition[k]) / 2\r\n            }\r\n        }\r\n    }\r\n    for(let j=0;j<=Math.ceil(selectMaxPosition(array)/ 500);j++){\r\n        if(sumDuration[j]>maxDuration){\r\n            scrollTo=stayPosition[j];\r\n            maxDuration=sumDuration[j];\r\n        }\r\n    }\r\n    return scrollTo;\r\n}\r\n//update above\r\n\r\n\r\nfunction getMostValuableVideo(array) {\r\n    let longestTime=0;\r\n    let valuableSnippet;\r\n    for (let i = 0; i <= array.length - 1; i++) {\r\n        let snippet=array[i].end_time-array[i].start_time;\r\n        if(snippet>longestTime){\r\n            valuableSnippet=array[i];\r\n            longestTime=snippet;\r\n        }\r\n    }\r\n    return valuableSnippet;\r\n}\r\n//get most valuable video snippet's url and value gives to video_url\r\nfunction valuableVideoUrl(vUrl, videoSnippets)\r\n{\r\n    if(!videoSnippets)\r\n    {\r\n        console.log(\"No Video Snippets at this Url: Wrong Passing!\");\r\n        return;\r\n    }\r\n    let videoSnippet = getMostValuableVideo(videoSnippets);\r\n    let uString = '&feature=youtu.be&t=' +Math.floor(videoSnippet.start_time);\r\n    return vUrl.concat(uString);\r\n}\r\n\r\n\r\n\r\n/**\r\n * Handling messages from content script.\r\n * @param request\r\n * @param sender\r\n * @param sendResponse\r\n * @returns {boolean}\r\n */\r\nfunction handleMessage(request, sender, sendResponse)\r\n{\r\n    //Sift the event type from the allowed list of behaviors.\r\n    let etype;\r\n    //Keys for the message, one of them being a behavior type.\r\n    let keys = Object.keys(request);\r\n    for(let index in keys)\r\n        if(behaviorTypes.includes(keys[index])){\r\n            etype = keys[index];\r\n            if (keys[index] === \"screenshot\")\r\n                capture(request.screenshot);\r\n        }\r\n\r\n    //Invalid message if no event type is given.\r\n    if(!etype) {\r\n        console.error(\"No Event Types Given! \", request);\r\n        return false;\r\n    }\r\n\r\n    if (behaviorTypes.includes(etype)) {\r\n        update(request.url, etype, request[etype]);\r\n    }\r\n    return true;\r\n}\r\n\r\n\r\n\r\n/**\r\n *\r\n * @param type\r\n * @param bhv\r\n * @param omniboxInput\r\n * @returns {String} The specific type of behavior the input matches.\r\n */\r\nfunction behaviorMatchesInput(type, bhv, omniboxInput) {\r\n    if(type === \"copy\")\r\n    {\r\n        //If a code segment is encountered.\r\n        if(bhv.is_code)\r\n            if(bhv.text.indexOf(omniboxInput) !== -1)\r\n                return \"code\";\r\n    }\r\n    if (bhv.title.toString().toLowerCase().includes(omniboxInput.toString().toLowerCase())){\r\n        // @Derek: I merge the title matching here to simplify the code. For default value, the\r\n        // subsequent html suggestion shouldn't do anything special, would be great to load the original site logo.\r\n        return \"default\";\r\n    }\r\n}\r\n\r\n\r\n//The snippet that contains the site-general information is passed in as\r\n//the third parameter, which is modified by this method.\r\nfunction storeSuggestionSnippet(bhvType, bhv, snippet)\r\n{\r\n    //The portable data carrier for omnibox suggestion to be returned.\r\n    let suggestBehavior = snippet;\r\n    if(bhvType === \"copy\") {\r\n        if(bhv.is_code) {\r\n            //Store the behavior-specific fields.\r\n            suggestBehavior[\"content\"] = bhv.text;\r\n            suggestBehavior[\"type\"] = \"code\";\r\n        }\r\n    }\r\n    else if(bhvType === \"video_snippet\") {\r\n        suggestBehavior[\"content\"] = suggestBehavior[\"title\"];\r\n        suggestBehavior[\"type\"] = \"video_snippet\";\r\n        suggestBehavior[\"url\"] = bhv;\r\n    }\r\n    //Add common quantities as section_id to the suggestion carrier.\r\n    //These are confined to those contained in the behavior itself, not the url,\r\n    //title, or query, which must be appended in background.omniboxHandler.\r\n    suggestBehavior[\"section_id\"] = bhv.section_id;\r\n}\r\n\r\nfunction makeSuggestionHTML(suggest)\r\n{\r\n    console.log(\"Suggestion Holder\", suggestionHolder);\r\n\r\n    let suggestions = [];\r\n    for(let i=0; i<suggestionHolder.length; i++) {\r\n\r\n        let suggestion = suggestionHolder[i];\r\n        let formattedSuggestion;\r\n        if(suggestion.type === \"code\")\r\n            formattedSuggestion = {\r\n                content: suggestion.content,\r\n                description: (suggestion.query.length===0?\"\":\r\n                    suggestion.query.toString() + \": \") + suggestion.content\r\n            };\r\n        else if(suggestion.type === \"video_snippet\")\r\n            formattedSuggestion =\r\n                {\r\n                    content: suggestion.content,\r\n                    description: (suggestion.query.length===0?\"\":\r\n                        suggestion.query.toString() + \": \") + suggestion.content\r\n                };\r\n\r\n        //Check if xml specific strings are encountered in the description.\r\n        for(let xmlChar in xmlChars)\r\n            if(formattedSuggestion.description.indexOf(xmlChar) !== -1)\r\n                formattedSuggestion.description =\r\n                    formattedSuggestion.description.split(xmlChar).join(xmlChars[xmlChar]);\r\n\r\n        suggestions.push(formattedSuggestion);\r\n    }\r\n    suggest(suggestions);\r\n}\r\n\r\n/**\r\n * Handling text inputs from the omnibox and generate suggestions\r\n *\r\n * For those types of behaviors that have no detailed content for matching, other\r\n * than the general title and the past queries of the site, their checking part\r\n * may be foregone in the background.behaviorMatchesInput method, but should\r\n * instead be recorded in the background.storeSuggestionSnippet method.\r\n * @param omniboxText The current text typed by the user in the omnibox.\r\n * @param suggest A function for populating suggestions.\r\n */\r\n\r\nfunction omniboxHandler(omniboxText, suggest)\r\n{\r\n    chrome.storage.local.get(null,\r\n        //All the behaviors organized by their urls as keys.\r\n        function (bhvItems) {\r\n            //A holder for any kind of previous behavior that may prompt a useful\r\n            //suggestion.\r\n            suggestionHolder = [];\r\n            //Loop through each url and examine if any of its behaviors matches the\r\n            //input given presently in the omnibox by the user.\r\n            for (let url in bhvItems) {\r\n                console.log(\"hey:\" + url);\r\n                //Behaviors contained under this url. All behaviors wished to be\r\n                //processed to prompt a suggestion individually should be\r\n                //included in this container.\r\n                let bhvs = {};\r\n                let bhvItm = bhvItems[url];\r\n                //The previously copied information from this page.\r\n                if (bhvItm.copy)\r\n                    bhvs[\"copy\"] = bhvItm.copy;\r\n\r\n                if(bhvItm.video_snippet) {\r\n                    console.log(\"video snippet\");\r\n                    console.log(valuableVideoUrl(url, bhvItm.video_snippet));\r\n                    //Select the video snippet to direct unto.\r\n                    bhvs[\"video_snippet\"] = ({url: valuableVideoUrl(url, bhvItm.video_snippet)});\r\n                }\r\n\r\n                //Extract the queries and title that may be used for matching.\r\n                //A list of associated query for this code snippet. The queries\r\n                //in this array must match the current omnibox input.\r\n                let queries = [];\r\n                //Check if this url, and hence this behavior, is\r\n                //associated with a query.\r\n                for (let idx in bhvItm.visit) {\r\n                    let visit = bhvItm.visit[idx];\r\n                    if (visit[\"query\"] !== null && query.toString().toLowerCase().includes(omniboxText.toString().toLowerCase()))\r\n                        queries.push(visit[\"query\"]);\r\n                }\r\n\r\n\r\n                for (let each_type in bhvs) {\r\n                    let behaviors = bhvs[each_type];\r\n                    //Determine for each behavior of this type if it matches\r\n                    //the current input given by the user.\r\n                    for (let bhvIndex in behaviors) {\r\n                        let bhv = behaviors[bhvIndex];\r\n                        //The specific type of behavior the input triggers. This\r\n                        //may modify the behavior type stored to one more specific,\r\n                        //like copy to code.\r\n\r\n                        if(behaviorMatchesInput(each_type, bhv, omniboxText)\r\n                            || queries.length !== 0) {\r\n                            console.log(\"Ready to Store!\");\r\n\r\n                            let snippet = {\r\n                                \"title\": bhvItm.title,\r\n                                \"url\": url,\r\n                                \"query\": queries\r\n                            };\r\n\r\n                            //Store this behavior accordingly. First specifically,\r\n                            //then add the common attributes.\r\n                            storeSuggestionSnippet(each_type, bhv, snippet);\r\n\r\n                            //Add this snippet for suggestion.\r\n                            suggestionHolder.push(snippet);\r\n                        }\r\n\r\n                    }\r\n                }\r\n            }\r\n            makeSuggestionHTML(suggest);\r\n        });\r\n}\r\n\r\n/**\r\n *\r\n * @param text\r\n * @param disposition\r\n */\r\nfunction acceptInput(text, disposition) {\r\n    // disposition: \"currentTab\", \"newForegroundTab\", or \"newBackgroundTab\"\r\n    //If previously extracted code segments match the current text, direct to them.\r\n    if (!isValidUrl(text) && !suggestionHolder) {\r\n        return;\r\n    }\r\n    switch (disposition) {\r\n        case \"currentTab\": {\r\n            //Default link using text.\r\n            let link = text;\r\n\r\n            for(let index in suggestionHolder)\r\n            {\r\n                //Snippet of title-bundled copied behavior.\r\n                let snippet = suggestionHolder[index];\r\n                console.log(snippet);\r\n                if(snippet.content.trim() === text)\r\n                {\r\n                    link = snippet.url;\r\n                    link = snippet.url.concat(snippet.section_id?\r\n                        (\"#\"+snippet.section_id):\"\");\r\n                    console.log(\"link \", link);\r\n                    break;\r\n                }\r\n            }\r\n            chrome.tabs.update({url: link});\r\n            break;\r\n        }\r\n        case \"newForegroundTab\": {\r\n            chrome.tabs.create({url: text});\r\n            break;\r\n        }\r\n        case \"newBackgroundTab\": {\r\n            chrome.tabs.create({url: text, active: false});\r\n            break;\r\n        }\r\n    }\r\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvanMvYmFja2dyb3VuZC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9qcy9iYWNrZ3JvdW5kLmpzPzgxMDQiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZ2xvYmFsIGNocm9tZSovXHJcbmxldCB2aWRlb191cmw7Ly9jcmVhdGUgdG8gY2hhbmdlIHRoZSB1cmwgb2YgdmlkZW8gc25pcHBldCBieSBaWkxcclxubGV0IGJlaGF2aW9yVHlwZXMgPSBbXCJjb3B5XCIsIFwiaGlnaGxpZ2h0XCIsIFwidmlkZW9fc25pcHBldFwiLCBcInN0YXlcIiwgXCJzY3JlZW5zaG90XCJdO1xyXG4vL1RoZSBjaGFyYWN0ZXJzIHRoYXQgaGF2ZSBhc3NvY2lhdGVkIG1lYW5pbmdzIGluIHhtbCBvZiBzdWdnZXN0aW9ucyB0aGF0XHJcbi8vbmVlZCB0byBiZSByZXBsYWNlZC4gVGhlIHJlcGxhY2VtZW50IGNoYXJhY3RlcnMgYXJlIGNvbnRhaW5lZCBhcyB2YWx1ZXNcclxuLy90byB0aGUga2V5cy5cclxubGV0IHhtbENoYXJzID0ge1wiJlwiOiBcIiZhbXA7XCJ9O1xyXG5cclxucmVxdWlyZShcImRvd25sb2FkanNcIik7XHJcblxyXG5mdW5jdGlvbiBpc1ZhbGlkVXJsKHRleHQpIHtcclxuICAgIGNvbnN0IHZhbGlkID0gLygoaHR0cHM/KTpcXC9cXC8pPygoW3d8V117M31cXC4pKyk/W2EtekEtWjAtOVxcLVxcLl17Myx9XFwuW2EtekEtWl17Mix9KFxcLlthLXpBLVpdezIsfSk/LztcclxuICAgIHJldHVybiB2YWxpZC50ZXN0KHRleHQpO1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gZ2V0Um9vdFVybChyVXJsKXtcclxuICAgIGlmKHJVcmwuaW5jbHVkZXMoXCImZmVhdHVyZT15b3V0dS5iZSZ0PVwiKSl7XHJcbiAgICAgICAgclVybD1yVXJsLnNwbGl0KFwiJmZlYXR1cmU9eW91dHUuYmUmdD1cIilbMF07XHJcbiAgICB9XHJcblxyXG4gICAgaWYoclVybC5pbmNsdWRlcyhcIiNcIikpe1xyXG4gICAgICAgIHJVcmw9clVybC5zcGxpdChcIiNcIilbMF07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gclVybDtcclxufVxyXG4vKipcclxuICogQSBsaXN0IG9mIHN1Z2dlc3Rpb25zIHdpdGggY29tbW9uIGZpZWxkcyBcInVybFwiLCBcInRpdGxlXCIsIGFuZCBcInF1ZXJ5XCIuIEVhY2hcclxuICogc3VnZ2VzdGlvbiBjb3JyZXNwb25kcyB0byBvbmUgcGFzdCBiZWhhdmlvciBvZiB0aGUgdXNlciB0aGF0IGlzIHByb21wdGVkIGJ5XHJcbiAqIHRoZSBwcmVzZW50IHRleHQgaW5wdXQgZ2l2ZW4gYnkgdGhlIHVzZXIgaW4gdGhlIG9tbmlib3guXHJcbiAqXHJcbiAqIFRoZSBtYXRjaGluZyBtZWNoYW5pc20gaXMgZGVmaW5lZCBpbiB0aGUganMvYmFja2dyb3VuZC5iZWhhdmlvck1hdGNoZXNJbnB1dFxyXG4gKiBtZXRob2QsIHdoaWNoIG9mZmVycyBzcGVjaWZpYyBtYXRjaGluZyBvdGhlciB0aGFuIHRoYXQgb2YgdGl0bGUgYW5kIHBhc3RcclxuICogcXVlcmllcy5cclxuICpcclxuICogT25jZSBhIGJlaGF2aW9yIG1hdGNoZXMgdGhlIGN1cnJlbnQgaW5wdXQsIGpzL2JhY2tncm91bmQuc3RvcmVTdWdnZXN0aW9uU25pcHBldFxyXG4gKiBmdW5jdGlvbiB3aWxsIGJlIGludm9rZWQgdG8gcHJvcGVybHkgc3RvcmUgdGhpcyBzdWdnZXN0aW9uLiBBIHByb3RvdHlwZSBob2xkZXJcclxuICogdGhhdCBjb250YWlucyB0aGUgYmFzaWMgZW50cmllcy0tdXJsLCB0aXRsZSwgcXVlcnktLXdpbGwgYmUgcGFzc2VkIGluIGFzIGFcclxuICogcGFyYW1ldGVyIGluIGNhc2UgdGhpcyBpbmZvcm1hdGlvbiBpcyBuZWNlc3NhcnkgZm9yIHNwZWNpZmljIHN0b3JhZ2UuIFRoZSBzdG9yYWdlXHJcbiAqIG9mIHRoaXMgcGFydGljdWxhciBzdWdnZXN0aW9uLWJlaGF2aW9yIG11c3QgYWxzbyBmaWxsIHRoZSBcImNvbnRlbnRcIiBmaWVsZCBvZlxyXG4gKiB0aGUgc25pcHBldC4gVGhlIHByb2Nlc3NpbmcgaXMgZG9uZSBieSB0aGUgbW9kaWZpY2F0aW9uIG9mIHRoZSBwYXNzZWQgaW5cclxuICogcHJvdG90eXBlIHNuaXBwZXQsIGFzIGFmb3JlbWVudGlvbmVkLlxyXG4gKlxyXG4gKiBTdWNjZWVkaW5nIHRoaXMsIHRoZSBzdWdnZXN0aW9uIHNuaXBwZXQsIHRoZSBob2xkZXIgb2YgdGhlIHJlbGV2YW50IGluZm9ybWF0aW9uXHJcbiAqIG9mIHRoZSBwYXN0IGJlaGF2aW9yIHRvIGJlIHByb21wdGVkIGFzIGEgc3VnZ2VzdGlvbiBpbiB0aGUgb21uaWJveCBpcyBzdG9yZWRcclxuICogaW4gdGhpcyBjb250YWluZXIsIHdoaWNoIHdpbGwgbW9kaWZpZWQgZWFjaCB0aW1lIHRoZSBpbnB1dCBjaGFuZ2VzLlxyXG4gKlxyXG4gKiBBcyB0aGUgc2VsZWN0aW9uIG9mIGFueSBzdWdnZXN0aW9uLCBvciBpbiBnZW5lcmFsIHRoZSBhc2NlcnRhaW5tZW50IG9mIGFuXHJcbiAqIGlucHV0IGluIHRoZSBvbW5pYm94IG11c3Qgc3VwZXJjZWRlIHNvbWUgY2hhbmdlIGluIGlucHV0LCB3aGljaCB0cmlnZ2VycyB0aGVcclxuICogcHJvcGVyIHByb2Nlc3NpbmcgYW5kIHBvcHVsYXRpb24gb2YgdGhpcyBob2xkZXIsIGFsbCB0aGUgYmVoYXZpb3JzIHRoYXQgY2FuXHJcbiAqIGVsaWNpdCBhIHNwZWNpYWwgZGlyZWN0aW9uLCBpLmUuIHRvIGEgc3BlY2lmaWMgc2l0ZSwgaXMgcHJvcGVybHkgc3RvcmVkIGluXHJcbiAqIHRoaXMgaG9sZGVyIGJlZm9yZSBqcy9iYWNrZ3JvdW5kLmFjY2VwdElucHV0IGlzIGludm9rZWQsIHdoaWNoIGNoZWNrcyBpZlxyXG4gKiB0aGUgaW5wdXQgbWF0Y2hlcyBhbnkgc3VnZ2VzdGlvbiBpbiB0aGlzIGNvbnRhaW5lci5cclxuICovXHJcbmxldCBzdWdnZXN0aW9uSG9sZGVyO1xyXG5jaHJvbWUub21uaWJveC5vbklucHV0Q2hhbmdlZC5hZGRMaXN0ZW5lcihvbW5pYm94SGFuZGxlcik7XHJcbmNocm9tZS5vbW5pYm94Lm9uSW5wdXRFbnRlcmVkLmFkZExpc3RlbmVyKGFjY2VwdElucHV0KTtcclxuY2hyb21lLnJ1bnRpbWUub25NZXNzYWdlLmFkZExpc3RlbmVyKGhhbmRsZU1lc3NhZ2UpO1xyXG5jaHJvbWUucnVudGltZS5vbkluc3RhbGxlZC5hZGRMaXN0ZW5lcihmdW5jdGlvbiAoKSB7XHJcbiAgICBjaHJvbWUuc3RvcmFnZS5sb2NhbC5jbGVhcihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY29uc3QgZXJyb3IgPSBjaHJvbWUucnVudGltZS5sYXN0RXJyb3I7XHJcbiAgICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59KTtcclxuXHJcblxyXG4vLyBXaGVuIGEgdGFiIGp1c3QgZ290IGNyZWF0ZWQuXHJcbmNocm9tZS50YWJzLm9uQ3JlYXRlZC5hZGRMaXN0ZW5lcihmdW5jdGlvbih0YWIpe1xyXG4gICAgbGV0IHRvU2F2ZSA9IHt9O1xyXG4gICAgdG9TYXZlW3RhYi5pZC50b1N0cmluZygpXSA9IFtdO1xyXG4gICAgY29uc29sZS5sb2coXCJpbml0aWFsaXppbmcgLi4gZm9yIHRhYiBcIiArIHRhYi5pZC50b1N0cmluZygpKTtcclxuICAgIGNocm9tZS5zdG9yYWdlLmxvY2FsLnNldCh0b1NhdmUpO1xyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBXaGVuIHRoZXJlIGlzIGEgY2hhbmdlZCB1cmwgZm9yIHNvbWUgdGFiLFxyXG4gKiAxKSBmZXRjaCB0aGUgdGhlIG9yaWdpbmFsIHF1ZXJ5IHdvcmRzIGZvciB0aGUgdXJsLCBhc3N1bWluZyB0aGUgdXJsIGlzIHJlZGlyZWN0ZWRcclxuICogZnJvbSBhIHByZXZpb3VzIHNlYXJjaCByZXN1bHQgcGFnZSBpbiB0aGUgc2FtZSB0YWJcclxuICogMikgc2F2ZSB0aGUgdXJsIHZpc2l0IHJlY29yZCAtIGlmIG5vIHZpc2l0IGluIHRoZSBwYXN0LCBjcmVhdGUgYSBlbnRyeSwgaWYgdGhlcmUgaXMsIHVwZGF0ZSB0aGUgdmlzaXQgdGltZVxyXG4gKiAzKSBzYXZlIHRoZSBxdWVyeSB0byB0aGUgcmVjb3JkLlxyXG4gKiA077yJbGV0IHRoZSBjb250ZW50IHNjcmlwdCBrbm93IHRoaXMgdXJsIGNoYW5nZSwgdG8gdXBkYXRlIFVJIChkcmF3IG1hcmtlcnMsIGhpZ2hsaWdodCB0ZXh0cywgc2Nyb2xsLCBldGMuKVxyXG4gKiA1KSBzYXZlIHRoaXMgdXJsIGhpc3RvcnkgdG8gdGFiLlxyXG4gKi9cclxuY2hyb21lLnRhYnMub25VcGRhdGVkLmFkZExpc3RlbmVyKGZ1bmN0aW9uKHRhYklkLCBjaGFuZ2VJbmZvLCB0YWIpIHtcclxuICAgIGxldCB0YWJVcmwgPSBnZXRSb290VXJsKHRhYi51cmwpO1xyXG4gICAgaWYgKGNoYW5nZUluZm8uc3RhdHVzID09PSBcImNvbXBsZXRlXCIgJiYgaXNWYWxpZFVybCh0YWJVcmwpKXtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIm5ldyB1cmwgZGV0ZWN0ZWQ6XCIgKyB0YWJVcmwgK1wiIGZvciB0YWIgXCIgKyB0YWJJZCk7XHJcbiAgICAgICAgbGV0IHF1ZXJ5ID0gbnVsbDtcclxuICAgICAgICAvL0xvb2sgdXAgdXJsIGhpc3RvcnkgZm9yIHRoZSBjdXJyZW50IHRhYi5cclxuICAgICAgICBjaHJvbWUuc3RvcmFnZS5sb2NhbC5nZXQoe1t0YWJJZC50b1N0cmluZygpXTpbXX0sIGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICAgIGxldCBwYXN0VXJscyA9IGl0ZW1bdGFiSWQudG9TdHJpbmcoKV07XHJcbiAgICAgICAgICAgIC8vIEZldGNoIHF1ZXJ5IGZyb20gdGhlIHVybCBoaXN0b3J5IG9mIHRoZSBjdXJyZW50IHRhYlxyXG4gICAgICAgICAgICBpZiAocGFzdFVybHMubGVuZ3RoICE9PSAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBsZXQgaSA9IHBhc3RVcmxzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIC8vVHJ5IGdldCB0aGUgbW9zdCByZWNlbnQgcXVlcnkuXHJcbiAgICAgICAgICAgICAgICB3aGlsZSgtLWk+PTApXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5XHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL0F0dGVtcHQgdG8gZXh0cmFjdCBxdWVyeS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnkgPSBleHRyYWN0UXVlcnlGcm9tVXJsKHBhc3RVcmxzW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2F0Y2goZXhjKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9Ta2lwLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy9RdWVyeSBleHRyYWN0ZWQgbXVzdCBiZSBhIHN0cmluZy5cclxuICAgICAgICAgICAgICAgICAgICBpZihxdWVyeSAhPT0gbnVsbCAmJiB0eXBlb2YgcXVlcnkgPT09IFwic3RyaW5nXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vVXBkYXRlIHRoZSBjdXJyZW50IHVybCB0byB0aGUgdXJsJ3MgYmVoYXZpb3IgaXRlbSBtYXAsIGlmIHRoZXJlIGlzbid0XHJcbiAgICAgICAgICAgIC8vb25lIHlldCwgY3JlYXRlIGl0LlxyXG4gICAgICAgICAgICBjaHJvbWUuc3RvcmFnZS5sb2NhbC5nZXQodGFiVXJsLCBmdW5jdGlvbiAodXJsRW50cnkpIHtcclxuICAgICAgICAgICAgICAgIC8vSWYgdGhpcyB1cmwgaGFzIG5vdCBiZWVuIHByZXZpb3VzbHkgc3RvcmVkLlxyXG4gICAgICAgICAgICAgICAgLy9tZXJnZSB0aGUgYmVoYXZpb3Igb2YgdmlkZW8gYW5kIHN0YXlcclxuICAgICAgICAgICAgICAgIGxldCB2aWRlb1NuaXBwZXQ9e307XHJcbiAgICAgICAgICAgICAgICBsZXQgcmlnaHRQb3NpdGlvbj1udWxsO1xyXG4gICAgICAgICAgICAgICAgaWYoIXVybEVudHJ5W3RhYlVybF0pXHJcbiAgICAgICAgICAgICAgICB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiVXJsIG9mIHRoaXMgdGFiIGhhcyBub3QgYmVlbiBwcmV2aW91c2x5IHN0b3JlZCFcIiwgdXJsRW50cnkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNhdmVVcmxJbmZvKHRhYlVybCwge3Zpc2l0Olt7dmlzaXRUaW1lOiBuZXcgRGF0ZSgpLCBxdWVyeTogcXVlcnl9XSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHRhYi50aXRsZX0pXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJVcmwgcHJldmlvdXNseSB2aXNpdGVkIVwiLCB1cmxFbnRyeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9UaGUgcHJldmlvdXMgYmVoYXZpb3JhbCBpbmZvcm1hdGlvbiBnYXJuZXJlZC5cclxuICAgICAgICAgICAgICAgICAgICBsZXQgYmVoYXZpb3IgPSB1cmxFbnRyeVt0YWJVcmxdO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQmVoYXZpb3IgXCIsIGJlaGF2aW9yKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYmVoYXZpb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJlaGF2aW9yW1widmlkZW9fc25pcHBldFwiXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlkZW9TbmlwcGV0ID0gZ2V0TW9zdFZhbHVhYmxlVmlkZW8oYmVoYXZpb3JbXCJ2aWRlb19zbmlwcGV0XCJdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHZpZGVvU25pcHBldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJlaGF2aW9yW1wic3RheVwiXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHRQb3NpdGlvbiA9IHNlbGVjdE1vc3RWYWx1YWJsZVN0YXkoYmVoYXZpb3JbXCJzdGF5XCJdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHJpZ2h0UG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNocm9tZS50YWJzLnNlbmRNZXNzYWdlKHRhYklkLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogdGFiVXJsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjpcIm5ld191cmxcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ2aWRlb1wiOiB2aWRlb1NuaXBwZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwicG9zaXRpb25cIjogcmlnaHRQb3NpdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChyZXNwb25zZSkge30pO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vQWRkIHRoZSBjdXJyZW50IHRpbWUgYW5kIGFzc29jaWF0ZWQgcXVlcnkgdG8gdGhpcyB1cmwuXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZpc2l0cyA9IGJlaGF2aW9yW1widmlzaXRcIl07XHJcbiAgICAgICAgICAgICAgICAgICAgdmlzaXRzLnB1c2goe3Zpc2l0VGltZTogbmV3IERhdGUoKSwgcXVlcnk6IHF1ZXJ5fSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2F2ZVVybEluZm8odGFiVXJsLCBiZWhhdmlvcilcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIC8vY2hyb21lLnRhYnMuc2VuZE1lc3NhZ2UodGFiSWQsIHt1cmw6IHRhYi51cmx9LCBmdW5jdGlvbihyZXNwb25zZSkge30pO1xyXG4gICAgICAgICAgICBwYXN0VXJscy5wdXNoKHRhYlVybCk7XHJcbiAgICAgICAgICAgIHNhdmVVcmxzVG9UYWIocGFzdFVybHMsIHRhYklkKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufSk7XHJcblxyXG4vKipcclxuICogQ29tcGFyZSBpZiB0d28gb2JqZWN0cyBoYXZlIGlkZW50aWNhbCBmaWVsZHMgYW5kIGlkZW50aWNhbCBjb3JyZXNwb25kaW5nIHZhbHVlcy5cclxuICogVGhlIGZpZWxkIFwidGltZVwiIGlzIG5vdCBjb21wYXJlZC5cclxuICogQXQgcHJlc2VudCwgY29tcGFyaW5nIHR3byBiZWhhdmlvcnMgaXMgcmVzdHJpY3RlZCB0byB0aGVpciBhY3R1YWwgaW5mb3JtYXRpb24sXHJcbiAqIHNvIGlmIHRoZSBkaWZmZXJlbmNlIGlzIG9ubHkgaW4gZXZlbnRfdHlwZSwgbGlrZSBcImNvcHlcIiBhbmQgXCJoaWdobGlnaHRcIiwgd2hpbGVcclxuICogdGhlaXIgY29udGVudCBvYmplY3QgaXMgdGhlIHNhbWUsIHRoZSByZXN1bHQgb2YgY29tcGFyaXNvbiB3aWxsIGJlIHRydWUuXHJcbiAqIEBwYXJhbSBvYmoxXHJcbiAqIEBwYXJhbSBvYmoyXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuZnVuY3Rpb24gY29tcGFyZShvYmoxLCBvYmoyKVxyXG57XHJcbiAgICAvL0ZpZWxkcyBvZiBib3RoIG9iamVjdHNcclxuICAgIGxldCBrZXlzMSA9IE9iamVjdC5rZXlzKG9iajEpO1xyXG4gICAgbGV0IGtleXMyID0gT2JqZWN0LmtleXMob2JqMik7XHJcbiAgICAvL1NvcnQgdGhlIGFycmF5cyBmb3IgY29tcGFyaXNvbi5cclxuICAgIGtleXMxLnNvcnQoKTtcclxuICAgIGtleXMyLnNvcnQoKTtcclxuICAgIGNvbnNvbGUubG9nKFwia2V5cyBcIiwga2V5czEsIGtleXMyKTtcclxuICAgIC8vSWYgdGhlIHR3byBvYmplY3RzIG5vIG5vdCBldmVuIGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIGtleXMuXHJcbiAgICBpZihrZXlzMS5sZW5ndGggIT09IGtleXMyLmxlbmd0aClcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAvL0NvbXBhcmUgcGVyIGZpZWxkOyBzcGFyZSB0aGUgXCJ0aW1lXCIgZmllbGQuXHJcbiAgICBmb3IobGV0IGluZGV4IGluIGtleXMxKVxyXG4gICAge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGtleXMxW2luZGV4XSwga2V5czJbaW5kZXhdLCBvYmoxW2tleXMxW2luZGV4XSwgb2JqMltrZXlzMltpbmRleF1dXSk7XHJcbiAgICAgICAgLy9JZiB0aGUgZmllbGQgbmFtZSBpcyBub3QgaWRlbnRpY2FsLlxyXG4gICAgICAgIGlmKGtleXMxW2luZGV4XSAhPT0ga2V5czJbaW5kZXhdKVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgLy9JZiB0aGUgdmFsdWUgaXMgbm90LiBTcGFyZSBcInRpbWVcIi5cclxuICAgICAgICBlbHNlIGlmKGtleXMxW2luZGV4XSAhPT0gXCJ0aW1lXCIgJiYgb2JqMVtrZXlzMVtpbmRleF1dICE9PSBvYmoyW2tleXMxW2luZGV4XV0pXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcblxyXG4vKipcclxuICogRXh0cmFjdCBxdWVyeSBnaXZlbiBhIHVybFxyXG4gKiBUT0RPOiBzdXBwb3J0IG1vcmUgdXJsIHBhdHRlcm4gdG8gZXh0cmFjdCBxdWVyaWVzXHJcbiAqIEBwYXJhbSB1cmxcclxuICogQHJldHVybnMgeyp9IHRoZSBleHRyYWN0ZWQgcXVlcnlcclxuICovXHJcbmZ1bmN0aW9uIGV4dHJhY3RRdWVyeUZyb21VcmwodXJsKXtcclxuICAgIGlmICh1cmwuaW5jbHVkZXMoXCJnb29nbGUuY29tXCIpKSB7XHJcbiAgICAgICAgY29uc3QgcmVnZXggPSAvKD88PXE9KS4qPyg/PSYpL3M7XHJcbiAgICAgICAgaWYgKHVybC5tYXRjaChyZWdleCkgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVybC5tYXRjaChyZWdleClbMF0ucmVwbGFjZSgvXFwrL2csICcgJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYodXJsLmluY2x1ZGVzKFwiLmFtYXpvbi5jb21cIikpe1xyXG4gICAgICAgIGNvbnN0IHJlZ2V4ID0gLyg/PD1rPSkuKj8oPz0mKS9zO1xyXG4gICAgICAgIGlmICh1cmwubWF0Y2gocmVnZXgpICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1cmwubWF0Y2gocmVnZXgpWzBdLnJlcGxhY2UoL1xcKy9nLCAnICcpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmKHVybC5pbmNsdWRlcyhcIi55ZWxwLmNvbVwiKSl7XHJcbiAgICAgICAgY29uc3QgcmVnZXggPSAvKD88PWZpbmRfZGVzYz0pLio/KD89JikvcztcclxuICAgICAgICBpZiAodXJsLm1hdGNoKHJlZ2V4KSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdXJsLm1hdGNoKHJlZ2V4KVswXS5yZXBsYWNlKC9cXCsvZywgJyAnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZih1cmwuaW5jbHVkZXMoXCIubGlua2VkaW4uY29tXCIpKXtcclxuICAgICAgICBjb25zdCByZWdleCA9IC8oPzw9a2V5d29yZHM9KS4qPyg/PSYpL3M7XHJcbiAgICAgICAgaWYgKHVybC5tYXRjaChyZWdleCkgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVybC5tYXRjaChyZWdleClbMF0ucmVwbGFjZSgvXFwrL2csICcgJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYodXJsLmluY2x1ZGVzKFwiLnlvdXR1YmUuY29tXCIpKXtcclxuICAgICAgICBjb25zdCByZWdleCA9IC9zZWFyY2hfcXVlcnk9KC4qKS87XHJcbiAgICAgICAgaWYgKHVybC5tYXRjaChyZWdleClbMV0hPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdXJsLm1hdGNoKHJlZ2V4KVsxXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZih1cmwuaW5jbHVkZXMoXCIuZ2l0aHViLmNvbVwifHxcIi5zdGFja292ZXJmbG93LmNvbVwifHxcIi5iYmMuY28udWtcInx8XCIudGVkLmNvbVwiKSl7XHJcbiAgICAgICAgY29uc3QgcmVnZXggPSAvcT0oLiopLztcclxuICAgICAgICBpZiAodXJsLm1hdGNoKHJlZ2V4KVsxXSE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1cmwubWF0Y2gocmVnZXgpWzFdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmKHVybC5pbmNsdWRlcyhcIi53aWtpcGVkaWEub3JnXCIpKXtcclxuICAgICAgICBjb25zdCByZWdleCA9IC93aWtpXFwvKC4qKS87XHJcbiAgICAgICAgaWYgKHVybC5tYXRjaChyZWdleClbMV0hPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdXJsLm1hdGNoKHJlZ2V4KVsxXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEluaXRpYWxpemVzIG9yIG1vZGlmaWVzIHRoZSBuYW1lc3BhY2UgZm9yIGFuIHVybCBvZiBpdHMgY29ycmVzcG9uZGluZyB2aXNpdFxyXG4gKiBpbmZvcm1hdGlvbiwgd2hpY2ggaXMgYW4gYXJyYXkgb2Ygb2JqZWN0cyB3aXRoIGtleXMgXCJ2aXNpdFRpbWVcIiwgYW5kIFwicXVlcnlcIjtcclxuICogdGhlIGxhdHRlciBtYXkgYmUgbnVsbC4gVGhpcyBtZXRob2QgaXMgaW52b2tlZCB3aGVuIGEgdGFiIGlzIG5ld2x5IGxvYWRlZC5cclxuICogVGhlIGluZm8gcGFyYW1ldGVyIG11c3QgYmUgdGhlIGVudGlyZSBtYXAgb2YgYmVoYXZpb3JhbCBpbmZvcm1hdGlvbiBhc3NvY2lhdGVkXHJcbiAqIHdpdGggdGhpcyB1cmwuXHJcbiAqIEBwYXJhbSB1cmwgVGhlIHVybCB3aG9zZSBjb3JyZXNwb25kaW5nIGJlaGF2aW9yYWwgaW5mb3JtYXRpb24gaXMgdG8gYmUgbW9kaWZpZWQuXHJcbiAqIEBwYXJhbSBpbmZvIFRoZSBlbnRpcmUgbWFwIG9mIGJlaGF2aW9yYWwgaW5mb3JtYXRpb24gYXNzb2NpYXRlZC5cclxuICovXHJcbmZ1bmN0aW9uIHNhdmVVcmxJbmZvKHVybCwgaW5mbylcclxue1xyXG4gICAgY2hyb21lLnN0b3JhZ2UubG9jYWwuc2V0KHtbdXJsXTogaW5mb30pO1xyXG59XHJcblxyXG4vKipcclxuICogU2F2ZSBhIGxpc3Qgb2YgdXJsIGFzIGhpc3RvcnkgZm9yIGEgdGFiXHJcbiAqIFRPRE86IGRlcmVrIC0gYWRkIHZpc2l0IHRpbWUgaW5mb3JtYXRpb24gZm9yIGVhY2ggdXJsLlxyXG4gKiBAcGFyYW0gdXJsc1xyXG4gKiBAcGFyYW0gdGFiSWRcclxuICovXHJcbmZ1bmN0aW9uIHNhdmVVcmxzVG9UYWIodXJscywgdGFiSWQpe1xyXG4gICAgY29uc29sZS5sb2coXCJzYXZlIHVybHMgdG8gdGFiIFwiKyB0YWJJZCk7XHJcbiAgICBsZXQgdG9TYXZlID0ge307XHJcbiAgICB0b1NhdmVbdGFiSWQudG9TdHJpbmcoKV0gPSAgdXJscztcclxuICAgIGNocm9tZS5zdG9yYWdlLmxvY2FsLnNldCh0b1NhdmUpO1xyXG59XHJcblxyXG4vKipcclxuICpcclxuICogQHBhcmFtIHN0clxyXG4gKiBAcGFyYW0gY29vcmRzXHJcbiAqIEBwYXJhbSBjYWxsYmFja1xyXG4gKi9cclxuZnVuY3Rpb24gY3JvcERhdGEoc3RyLCBjb29yZHMsIGNhbGxiYWNrKSB7XHJcbiAgICBsZXQgaW1nID0gbmV3IEltYWdlKCk7XHJcblxyXG4gICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGxldCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgICAgICBjYW52YXMud2lkdGggPSBjb29yZHMudztcclxuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gY29vcmRzLmg7XHJcblxyXG4gICAgICAgIGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLmRyYXdJbWFnZShpbWcsIGNvb3Jkcy54KndpbmRvdy5kZXZpY2VQaXhlbFJhdGlvLCBjb29yZHMueSp3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbywgY29vcmRzLncqd2luZG93LmRldmljZVBpeGVsUmF0aW8sIGNvb3Jkcy5oKndpbmRvdy5kZXZpY2VQaXhlbFJhdGlvLCAwLCAwLCBjb29yZHMudywgY29vcmRzLmgpO1xyXG5cclxuICAgICAgICBjYWxsYmFjayh7ZGF0YVVyaTogY2FudmFzLnRvRGF0YVVSTCgpfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGltZy5zcmMgPSBzdHI7XHJcbn1cclxuXHJcblxyXG4vKipcclxuICpcclxuICogQHBhcmFtIF9zY3JlZW5zaG90T2JqXHJcbiAqL1xyXG5mdW5jdGlvbiBjYXB0dXJlKF9zY3JlZW5zaG90T2JqKSB7XHJcbiAgICBjaHJvbWUudGFicy5jYXB0dXJlVmlzaWJsZVRhYihudWxsLCB7Zm9ybWF0OiBcInBuZ1wifSwgZnVuY3Rpb24oZGF0YSkge1xyXG5cclxuICAgICAgICBjcm9wRGF0YShkYXRhLCBfc2NyZWVuc2hvdE9iai5jb29yZGluYXRlcywgZnVuY3Rpb24oZGF0YSkge1xyXG4gICAgICAgICAgICBkb3dubG9hZChkYXRhLmRhdGFVcmksIF9zY3JlZW5zaG90T2JqLmZpbGVuYW1lLCBcImltYWdlL3BsYWluXCIpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogVXBkYXRlLCBvciBhZGQsIGEgYmVoYXZpb3IgaXRlbSBvbiB0aGUgZ2l2ZW4gd2ViIHBhZ2UuIEVhY2ggdXJsIGNvcnJlc3BvbmRzIHdpdGhcclxuICogYSBtYXAgdGhhdCBjb250YWlucyBkaWZmZXJlbnQgYmVoYXZpb3IgY29kZXMgYXMga2V5cyBhbmQgYW4gYXJyYXkgdGhhdCBjb250YWluc1xyXG4gKiBhbGwgYmVoYXZpb3JhbCBpbmZvcm1hdGlvbiBvZiB0aGlzIHR5cGUgb2YgYmVoYXZpb3IuIEZvciBjZXJ0YWluIGluZm9ybWF0aW9uLCBhc1xyXG4gKiB0aXRsZSwgd2hpY2ggZG9lcyBub3QgcmVhbGx5IGFjY291bnQgZm9yIGEgYmVoYXZpb3IgdGhhdCBjYW4gb2NjdXIgbW9yZSB0aGFuIG9uY2UsXHJcbiAqIHRoZWlyIGNvcnJlc3BvbmRpbmcgdmFsdWUgbWF5IGJlIGEgc2luZ2xlIHZhbHVlLlxyXG4gKiBAcGFyYW0gdXJsIFRoZSB1cmwgYXNzb2NpYXRlZCB3aXRoIHRoaXMgaW5mb3JtYXRpb24uXHJcbiAqIEBwYXJhbSBiZWhhdmlvclR5cGUgVGhlIHR5cGUgb2YgYmVoYXZpb3IsIGFzIGRlbGluZWF0ZWQgaW4gdGhlIGJlaGF2aW9yIGNvZGUgY29udGFpbmVyLlxyXG4gKiBAcGFyYW0gYmVoYXZpb3IgVGhlIGFjdHVhbCBidW5kbGUgb2YgYmVoYXZpb3JhbCBpbmZvcm1hdGlvbiB0byBiZSBzdG9yZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiB1cGRhdGUodXJsLCBiZWhhdmlvclR5cGUsIGJlaGF2aW9yKVxyXG57XHJcbiAgICAvL0lmIG5vIHByZXZpb3VzIHN0b3JhZ2Ugb2YgYmVoYXZpb3IgZXhpc3RzIHVuZGVyIHRoaXMgdXJsLCByZXN1bHQgd291bGQgYmUge30uXHJcbiAgICBjaHJvbWUuc3RvcmFnZS5sb2NhbC5nZXQodXJsLCBmdW5jdGlvbiAocmVzdWx0KVxyXG4gICAge1xyXG4gICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBleGlzdGluZyBiZWhhdmlvcnMgc3RvcmVkIHlldCB0byB0aGlzIHVybCxcclxuICAgICAgICAvLyBwcm92aWRlIGEgY29udGFpbmVyLlxyXG4gICAgICAgIGxldCBleGlzdGluZ0JlaGF2aW9ycztcclxuICAgICAgICBpZighcmVzdWx0W3VybF0pXHJcbiAgICAgICAgICAgIGV4aXN0aW5nQmVoYXZpb3JzID0ge307XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICBleGlzdGluZ0JlaGF2aW9ycyA9IHJlc3VsdFt1cmxdO1xyXG4gICAgICAgIC8vQWxsIHByZXZpb3VzIGJlaGF2aW9ycyBvZiB0aGlzIGNhdGVnb3J5LlxyXG4gICAgICAgIGxldCBiaHZzO1xyXG4gICAgICAgIC8vV2hldGhlciB0aGUgY3VycmVudCBiZWhhdmlvciBpcyBhIGR1cGxpY2F0ZSBpbiBjb250ZW50IG9mIG9uZSByZWNvcmRlZFxyXG4gICAgICAgIC8vYmVmb3JlLlxyXG4gICAgICAgIGxldCBpc0R1cGxpY2F0ZSA9IGZhbHNlO1xyXG4gICAgICAgIC8vIEFwcGVuZCB0aGUgbmV3IGJlaGF2aW9yIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3Qgb2YgdGhpcyB0eXBlIG9mIGJlaGF2aW9yXHJcbiAgICAgICAgaWYoIXJlc3VsdFt1cmxdIHx8ICFleGlzdGluZ0JlaGF2aW9yc1tiZWhhdmlvclR5cGVdKVxyXG4gICAgICAgICAgICBleGlzdGluZ0JlaGF2aW9yc1tiZWhhdmlvclR5cGVdID0gW107XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYmh2cyA9IGV4aXN0aW5nQmVoYXZpb3JzW2JlaGF2aW9yVHlwZV07XHJcbiAgICAgICAgICAgIC8vQ2hlY2sgaWYgYSBkdXBsaWNhdGUgYmVoYXZpb3Igb2YgYSBkaWZmZXJlbnQgYWNjZXNzIHRpbWUgaXMgZW5jb3VudGVyZWQuXHJcbiAgICAgICAgICAgIGZvcihsZXQgaW5kZXggaW4gYmh2cylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYoY29tcGFyZShiaHZzW2luZGV4XSwgYmVoYXZpb3IpKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGlzRHVwbGljYXRlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBiaHZzW2luZGV4XS50aW1lLnB1c2goYmVoYXZpb3IudGltZVswXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNEdXBsaWNhdGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJodnMgPSBleGlzdGluZ0JlaGF2aW9yc1tiZWhhdmlvclR5cGVdO1xyXG4gICAgICAgIGlmKCFpc0R1cGxpY2F0ZSlcclxuICAgICAgICAvL0FwcGVuZCB0aGlzIGJlaGF2aW9yIGFzIG5ldyBiZWhhdmlvciBpZiBub25lIHdpdGggdGhlIHNhbWUgY29udGVudFxyXG4gICAgICAgIC8vaXMgZm91bmQuXHJcbiAgICAgICAgICAgIGJodnMucHVzaChiZWhhdmlvcik7XHJcbiAgICAgICAgLy9UaGUgdXJsLWFzc29jaWF0ZWQgYmVoYXZpb3IgcmVjb3JkLlxyXG4gICAgICAgIGxldCB0b1NhdmUgPSB7fTtcclxuICAgICAgICB0b1NhdmVbdXJsXSA9IGV4aXN0aW5nQmVoYXZpb3JzO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGV4aXN0aW5nQmVoYXZpb3JzKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIkJlaGF2aW9yIFN0b3JlZCBcIiwgdG9TYXZlKTtcclxuICAgICAgICBjaHJvbWUuc3RvcmFnZS5sb2NhbC5zZXQodG9TYXZlKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG4vKipcclxuICogU2VsZWN0aW5nIGEgbW9zdCBwcm9iYWJsZSBzdGF5IHVzZXJzIHdvdWxkIGxpa2UgdG8gcmV2aXNpdFxyXG4gKiBUT0RPOiBAWlpMIC0gQ29uc2lkZXIgc3RheSBmcmVxdWVuY3lcclxuICogQHBhcmFtIGFycmF5XHJcbiAqIEByZXR1cm5zIHsqfVxyXG4gKi9cclxuLy91cGRhdGUgY29uc2lkZXIgc3RheSBmcmVxdWVuY3lcclxuZnVuY3Rpb24gc2VsZWN0TWF4UG9zaXRpb24oYXJyYXkpe1xyXG4gICAgbGV0IG1heFBvc2l0aW9uPTA7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBhcnJheS5sZW5ndGggLSAxOyBpKyspIHtcclxuICAgICAgICBpZiAoYXJyYXlbaV0ucG9zaXRpb24gPiBtYXhQb3NpdGlvbikge1xyXG4gICAgICAgICAgICBtYXhQb3NpdGlvbiA9IGFycmF5W2ldLnBvc2l0aW9uO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBtYXhQb3NpdGlvbjtcclxufVxyXG4vL1dpbmRvdyBtYXhpbWl6YXRpb24gYWJvdXQgMTAwMCBhIHBhZ2UsZGl2aWRlIGJ5IDUwMCBhIHBhcnRcclxuZnVuY3Rpb24gc2VsZWN0TW9zdFZhbHVhYmxlU3RheShhcnJheSkge1xyXG4gICAgbGV0IHN1bUR1cmF0aW9uID0gW107XHJcbiAgICBsZXQgc3RheVBvc2l0aW9uPVtdO1xyXG4gICAgbGV0IHNjcm9sbFRvO1xyXG4gICAgbGV0IG1heER1cmF0aW9uPTA7XHJcbiAgICBsZXQgayA9IE1hdGguY2VpbChzZWxlY3RNYXhQb3NpdGlvbihhcnJheSkvIDUwMCk7XHJcbiAgICBmb3IgKGs7IGsgPj0wOyBrLS0pIHtcclxuICAgICAgICBzdW1EdXJhdGlvbltrXT0wO1xyXG4gICAgICAgIHN0YXlQb3NpdGlvbltrXT0wO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IGFycmF5Lmxlbmd0aCAtIDE7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoYXJyYXlbaV0ucG9zaXRpb24gPiA1MDAgKiAoayAtIDEpICYmIGFycmF5W2ldLnBvc2l0aW9uIDw9IDUwMCAqIGspIHtcclxuICAgICAgICAgICAgICAgIHN1bUR1cmF0aW9uW2tdID0gc3VtRHVyYXRpb25ba10gKyBhcnJheVtpXS5kdXJhdGlvbjtcclxuICAgICAgICAgICAgICAgIHN0YXlQb3NpdGlvbltrXSA9IChhcnJheVtpXS5wb3NpdGlvbiArIHN0YXlQb3NpdGlvbltrXSkgLyAyXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmb3IobGV0IGo9MDtqPD1NYXRoLmNlaWwoc2VsZWN0TWF4UG9zaXRpb24oYXJyYXkpLyA1MDApO2orKyl7XHJcbiAgICAgICAgaWYoc3VtRHVyYXRpb25bal0+bWF4RHVyYXRpb24pe1xyXG4gICAgICAgICAgICBzY3JvbGxUbz1zdGF5UG9zaXRpb25bal07XHJcbiAgICAgICAgICAgIG1heER1cmF0aW9uPXN1bUR1cmF0aW9uW2pdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBzY3JvbGxUbztcclxufVxyXG4vL3VwZGF0ZSBhYm92ZVxyXG5cclxuXHJcbmZ1bmN0aW9uIGdldE1vc3RWYWx1YWJsZVZpZGVvKGFycmF5KSB7XHJcbiAgICBsZXQgbG9uZ2VzdFRpbWU9MDtcclxuICAgIGxldCB2YWx1YWJsZVNuaXBwZXQ7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBhcnJheS5sZW5ndGggLSAxOyBpKyspIHtcclxuICAgICAgICBsZXQgc25pcHBldD1hcnJheVtpXS5lbmRfdGltZS1hcnJheVtpXS5zdGFydF90aW1lO1xyXG4gICAgICAgIGlmKHNuaXBwZXQ+bG9uZ2VzdFRpbWUpe1xyXG4gICAgICAgICAgICB2YWx1YWJsZVNuaXBwZXQ9YXJyYXlbaV07XHJcbiAgICAgICAgICAgIGxvbmdlc3RUaW1lPXNuaXBwZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbHVhYmxlU25pcHBldDtcclxufVxyXG4vL2dldCBtb3N0IHZhbHVhYmxlIHZpZGVvIHNuaXBwZXQncyB1cmwgYW5kIHZhbHVlIGdpdmVzIHRvIHZpZGVvX3VybFxyXG5mdW5jdGlvbiB2YWx1YWJsZVZpZGVvVXJsKHZVcmwsIHZpZGVvU25pcHBldHMpXHJcbntcclxuICAgIGlmKCF2aWRlb1NuaXBwZXRzKVxyXG4gICAge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiTm8gVmlkZW8gU25pcHBldHMgYXQgdGhpcyBVcmw6IFdyb25nIFBhc3NpbmchXCIpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGxldCB2aWRlb1NuaXBwZXQgPSBnZXRNb3N0VmFsdWFibGVWaWRlbyh2aWRlb1NuaXBwZXRzKTtcclxuICAgIGxldCB1U3RyaW5nID0gJyZmZWF0dXJlPXlvdXR1LmJlJnQ9JyArTWF0aC5mbG9vcih2aWRlb1NuaXBwZXQuc3RhcnRfdGltZSk7XHJcbiAgICByZXR1cm4gdlVybC5jb25jYXQodVN0cmluZyk7XHJcbn1cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIEhhbmRsaW5nIG1lc3NhZ2VzIGZyb20gY29udGVudCBzY3JpcHQuXHJcbiAqIEBwYXJhbSByZXF1ZXN0XHJcbiAqIEBwYXJhbSBzZW5kZXJcclxuICogQHBhcmFtIHNlbmRSZXNwb25zZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbmZ1bmN0aW9uIGhhbmRsZU1lc3NhZ2UocmVxdWVzdCwgc2VuZGVyLCBzZW5kUmVzcG9uc2UpXHJcbntcclxuICAgIC8vU2lmdCB0aGUgZXZlbnQgdHlwZSBmcm9tIHRoZSBhbGxvd2VkIGxpc3Qgb2YgYmVoYXZpb3JzLlxyXG4gICAgbGV0IGV0eXBlO1xyXG4gICAgLy9LZXlzIGZvciB0aGUgbWVzc2FnZSwgb25lIG9mIHRoZW0gYmVpbmcgYSBiZWhhdmlvciB0eXBlLlxyXG4gICAgbGV0IGtleXMgPSBPYmplY3Qua2V5cyhyZXF1ZXN0KTtcclxuICAgIGZvcihsZXQgaW5kZXggaW4ga2V5cylcclxuICAgICAgICBpZihiZWhhdmlvclR5cGVzLmluY2x1ZGVzKGtleXNbaW5kZXhdKSl7XHJcbiAgICAgICAgICAgIGV0eXBlID0ga2V5c1tpbmRleF07XHJcbiAgICAgICAgICAgIGlmIChrZXlzW2luZGV4XSA9PT0gXCJzY3JlZW5zaG90XCIpXHJcbiAgICAgICAgICAgICAgICBjYXB0dXJlKHJlcXVlc3Quc2NyZWVuc2hvdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIC8vSW52YWxpZCBtZXNzYWdlIGlmIG5vIGV2ZW50IHR5cGUgaXMgZ2l2ZW4uXHJcbiAgICBpZighZXR5cGUpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKFwiTm8gRXZlbnQgVHlwZXMgR2l2ZW4hIFwiLCByZXF1ZXN0KTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGJlaGF2aW9yVHlwZXMuaW5jbHVkZXMoZXR5cGUpKSB7XHJcbiAgICAgICAgdXBkYXRlKHJlcXVlc3QudXJsLCBldHlwZSwgcmVxdWVzdFtldHlwZV0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSB0eXBlXHJcbiAqIEBwYXJhbSBiaHZcclxuICogQHBhcmFtIG9tbmlib3hJbnB1dFxyXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgc3BlY2lmaWMgdHlwZSBvZiBiZWhhdmlvciB0aGUgaW5wdXQgbWF0Y2hlcy5cclxuICovXHJcbmZ1bmN0aW9uIGJlaGF2aW9yTWF0Y2hlc0lucHV0KHR5cGUsIGJodiwgb21uaWJveElucHV0KSB7XHJcbiAgICBpZih0eXBlID09PSBcImNvcHlcIilcclxuICAgIHtcclxuICAgICAgICAvL0lmIGEgY29kZSBzZWdtZW50IGlzIGVuY291bnRlcmVkLlxyXG4gICAgICAgIGlmKGJodi5pc19jb2RlKVxyXG4gICAgICAgICAgICBpZihiaHYudGV4dC5pbmRleE9mKG9tbmlib3hJbnB1dCkgIT09IC0xKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiY29kZVwiO1xyXG4gICAgfVxyXG4gICAgaWYgKGJodi50aXRsZS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMob21uaWJveElucHV0LnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKSkpe1xyXG4gICAgICAgIC8vIEBEZXJlazogSSBtZXJnZSB0aGUgdGl0bGUgbWF0Y2hpbmcgaGVyZSB0byBzaW1wbGlmeSB0aGUgY29kZS4gRm9yIGRlZmF1bHQgdmFsdWUsIHRoZVxyXG4gICAgICAgIC8vIHN1YnNlcXVlbnQgaHRtbCBzdWdnZXN0aW9uIHNob3VsZG4ndCBkbyBhbnl0aGluZyBzcGVjaWFsLCB3b3VsZCBiZSBncmVhdCB0byBsb2FkIHRoZSBvcmlnaW5hbCBzaXRlIGxvZ28uXHJcbiAgICAgICAgcmV0dXJuIFwiZGVmYXVsdFwiO1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuLy9UaGUgc25pcHBldCB0aGF0IGNvbnRhaW5zIHRoZSBzaXRlLWdlbmVyYWwgaW5mb3JtYXRpb24gaXMgcGFzc2VkIGluIGFzXHJcbi8vdGhlIHRoaXJkIHBhcmFtZXRlciwgd2hpY2ggaXMgbW9kaWZpZWQgYnkgdGhpcyBtZXRob2QuXHJcbmZ1bmN0aW9uIHN0b3JlU3VnZ2VzdGlvblNuaXBwZXQoYmh2VHlwZSwgYmh2LCBzbmlwcGV0KVxyXG57XHJcbiAgICAvL1RoZSBwb3J0YWJsZSBkYXRhIGNhcnJpZXIgZm9yIG9tbmlib3ggc3VnZ2VzdGlvbiB0byBiZSByZXR1cm5lZC5cclxuICAgIGxldCBzdWdnZXN0QmVoYXZpb3IgPSBzbmlwcGV0O1xyXG4gICAgaWYoYmh2VHlwZSA9PT0gXCJjb3B5XCIpIHtcclxuICAgICAgICBpZihiaHYuaXNfY29kZSkge1xyXG4gICAgICAgICAgICAvL1N0b3JlIHRoZSBiZWhhdmlvci1zcGVjaWZpYyBmaWVsZHMuXHJcbiAgICAgICAgICAgIHN1Z2dlc3RCZWhhdmlvcltcImNvbnRlbnRcIl0gPSBiaHYudGV4dDtcclxuICAgICAgICAgICAgc3VnZ2VzdEJlaGF2aW9yW1widHlwZVwiXSA9IFwiY29kZVwiO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYoYmh2VHlwZSA9PT0gXCJ2aWRlb19zbmlwcGV0XCIpIHtcclxuICAgICAgICBzdWdnZXN0QmVoYXZpb3JbXCJjb250ZW50XCJdID0gc3VnZ2VzdEJlaGF2aW9yW1widGl0bGVcIl07XHJcbiAgICAgICAgc3VnZ2VzdEJlaGF2aW9yW1widHlwZVwiXSA9IFwidmlkZW9fc25pcHBldFwiO1xyXG4gICAgICAgIHN1Z2dlc3RCZWhhdmlvcltcInVybFwiXSA9IGJodjtcclxuICAgIH1cclxuICAgIC8vQWRkIGNvbW1vbiBxdWFudGl0aWVzIGFzIHNlY3Rpb25faWQgdG8gdGhlIHN1Z2dlc3Rpb24gY2Fycmllci5cclxuICAgIC8vVGhlc2UgYXJlIGNvbmZpbmVkIHRvIHRob3NlIGNvbnRhaW5lZCBpbiB0aGUgYmVoYXZpb3IgaXRzZWxmLCBub3QgdGhlIHVybCxcclxuICAgIC8vdGl0bGUsIG9yIHF1ZXJ5LCB3aGljaCBtdXN0IGJlIGFwcGVuZGVkIGluIGJhY2tncm91bmQub21uaWJveEhhbmRsZXIuXHJcbiAgICBzdWdnZXN0QmVoYXZpb3JbXCJzZWN0aW9uX2lkXCJdID0gYmh2LnNlY3Rpb25faWQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1ha2VTdWdnZXN0aW9uSFRNTChzdWdnZXN0KVxyXG57XHJcbiAgICBjb25zb2xlLmxvZyhcIlN1Z2dlc3Rpb24gSG9sZGVyXCIsIHN1Z2dlc3Rpb25Ib2xkZXIpO1xyXG5cclxuICAgIGxldCBzdWdnZXN0aW9ucyA9IFtdO1xyXG4gICAgZm9yKGxldCBpPTA7IGk8c3VnZ2VzdGlvbkhvbGRlci5sZW5ndGg7IGkrKykge1xyXG5cclxuICAgICAgICBsZXQgc3VnZ2VzdGlvbiA9IHN1Z2dlc3Rpb25Ib2xkZXJbaV07XHJcbiAgICAgICAgbGV0IGZvcm1hdHRlZFN1Z2dlc3Rpb247XHJcbiAgICAgICAgaWYoc3VnZ2VzdGlvbi50eXBlID09PSBcImNvZGVcIilcclxuICAgICAgICAgICAgZm9ybWF0dGVkU3VnZ2VzdGlvbiA9IHtcclxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHN1Z2dlc3Rpb24uY29udGVudCxcclxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAoc3VnZ2VzdGlvbi5xdWVyeS5sZW5ndGg9PT0wP1wiXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgc3VnZ2VzdGlvbi5xdWVyeS50b1N0cmluZygpICsgXCI6IFwiKSArIHN1Z2dlc3Rpb24uY29udGVudFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIGVsc2UgaWYoc3VnZ2VzdGlvbi50eXBlID09PSBcInZpZGVvX3NuaXBwZXRcIilcclxuICAgICAgICAgICAgZm9ybWF0dGVkU3VnZ2VzdGlvbiA9XHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogc3VnZ2VzdGlvbi5jb250ZW50LFxyXG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAoc3VnZ2VzdGlvbi5xdWVyeS5sZW5ndGg9PT0wP1wiXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Z2dlc3Rpb24ucXVlcnkudG9TdHJpbmcoKSArIFwiOiBcIikgKyBzdWdnZXN0aW9uLmNvbnRlbnRcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vQ2hlY2sgaWYgeG1sIHNwZWNpZmljIHN0cmluZ3MgYXJlIGVuY291bnRlcmVkIGluIHRoZSBkZXNjcmlwdGlvbi5cclxuICAgICAgICBmb3IobGV0IHhtbENoYXIgaW4geG1sQ2hhcnMpXHJcbiAgICAgICAgICAgIGlmKGZvcm1hdHRlZFN1Z2dlc3Rpb24uZGVzY3JpcHRpb24uaW5kZXhPZih4bWxDaGFyKSAhPT0gLTEpXHJcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWRTdWdnZXN0aW9uLmRlc2NyaXB0aW9uID1cclxuICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZWRTdWdnZXN0aW9uLmRlc2NyaXB0aW9uLnNwbGl0KHhtbENoYXIpLmpvaW4oeG1sQ2hhcnNbeG1sQ2hhcl0pO1xyXG5cclxuICAgICAgICBzdWdnZXN0aW9ucy5wdXNoKGZvcm1hdHRlZFN1Z2dlc3Rpb24pO1xyXG4gICAgfVxyXG4gICAgc3VnZ2VzdChzdWdnZXN0aW9ucyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBIYW5kbGluZyB0ZXh0IGlucHV0cyBmcm9tIHRoZSBvbW5pYm94IGFuZCBnZW5lcmF0ZSBzdWdnZXN0aW9uc1xyXG4gKlxyXG4gKiBGb3IgdGhvc2UgdHlwZXMgb2YgYmVoYXZpb3JzIHRoYXQgaGF2ZSBubyBkZXRhaWxlZCBjb250ZW50IGZvciBtYXRjaGluZywgb3RoZXJcclxuICogdGhhbiB0aGUgZ2VuZXJhbCB0aXRsZSBhbmQgdGhlIHBhc3QgcXVlcmllcyBvZiB0aGUgc2l0ZSwgdGhlaXIgY2hlY2tpbmcgcGFydFxyXG4gKiBtYXkgYmUgZm9yZWdvbmUgaW4gdGhlIGJhY2tncm91bmQuYmVoYXZpb3JNYXRjaGVzSW5wdXQgbWV0aG9kLCBidXQgc2hvdWxkXHJcbiAqIGluc3RlYWQgYmUgcmVjb3JkZWQgaW4gdGhlIGJhY2tncm91bmQuc3RvcmVTdWdnZXN0aW9uU25pcHBldCBtZXRob2QuXHJcbiAqIEBwYXJhbSBvbW5pYm94VGV4dCBUaGUgY3VycmVudCB0ZXh0IHR5cGVkIGJ5IHRoZSB1c2VyIGluIHRoZSBvbW5pYm94LlxyXG4gKiBAcGFyYW0gc3VnZ2VzdCBBIGZ1bmN0aW9uIGZvciBwb3B1bGF0aW5nIHN1Z2dlc3Rpb25zLlxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIG9tbmlib3hIYW5kbGVyKG9tbmlib3hUZXh0LCBzdWdnZXN0KVxyXG57XHJcbiAgICBjaHJvbWUuc3RvcmFnZS5sb2NhbC5nZXQobnVsbCxcclxuICAgICAgICAvL0FsbCB0aGUgYmVoYXZpb3JzIG9yZ2FuaXplZCBieSB0aGVpciB1cmxzIGFzIGtleXMuXHJcbiAgICAgICAgZnVuY3Rpb24gKGJodkl0ZW1zKSB7XHJcbiAgICAgICAgICAgIC8vQSBob2xkZXIgZm9yIGFueSBraW5kIG9mIHByZXZpb3VzIGJlaGF2aW9yIHRoYXQgbWF5IHByb21wdCBhIHVzZWZ1bFxyXG4gICAgICAgICAgICAvL3N1Z2dlc3Rpb24uXHJcbiAgICAgICAgICAgIHN1Z2dlc3Rpb25Ib2xkZXIgPSBbXTtcclxuICAgICAgICAgICAgLy9Mb29wIHRocm91Z2ggZWFjaCB1cmwgYW5kIGV4YW1pbmUgaWYgYW55IG9mIGl0cyBiZWhhdmlvcnMgbWF0Y2hlcyB0aGVcclxuICAgICAgICAgICAgLy9pbnB1dCBnaXZlbiBwcmVzZW50bHkgaW4gdGhlIG9tbmlib3ggYnkgdGhlIHVzZXIuXHJcbiAgICAgICAgICAgIGZvciAobGV0IHVybCBpbiBiaHZJdGVtcykge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJoZXk6XCIgKyB1cmwpO1xyXG4gICAgICAgICAgICAgICAgLy9CZWhhdmlvcnMgY29udGFpbmVkIHVuZGVyIHRoaXMgdXJsLiBBbGwgYmVoYXZpb3JzIHdpc2hlZCB0byBiZVxyXG4gICAgICAgICAgICAgICAgLy9wcm9jZXNzZWQgdG8gcHJvbXB0IGEgc3VnZ2VzdGlvbiBpbmRpdmlkdWFsbHkgc2hvdWxkIGJlXHJcbiAgICAgICAgICAgICAgICAvL2luY2x1ZGVkIGluIHRoaXMgY29udGFpbmVyLlxyXG4gICAgICAgICAgICAgICAgbGV0IGJodnMgPSB7fTtcclxuICAgICAgICAgICAgICAgIGxldCBiaHZJdG0gPSBiaHZJdGVtc1t1cmxdO1xyXG4gICAgICAgICAgICAgICAgLy9UaGUgcHJldmlvdXNseSBjb3BpZWQgaW5mb3JtYXRpb24gZnJvbSB0aGlzIHBhZ2UuXHJcbiAgICAgICAgICAgICAgICBpZiAoYmh2SXRtLmNvcHkpXHJcbiAgICAgICAgICAgICAgICAgICAgYmh2c1tcImNvcHlcIl0gPSBiaHZJdG0uY29weTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZihiaHZJdG0udmlkZW9fc25pcHBldCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwidmlkZW8gc25pcHBldFwiKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyh2YWx1YWJsZVZpZGVvVXJsKHVybCwgYmh2SXRtLnZpZGVvX3NuaXBwZXQpKTtcclxuICAgICAgICAgICAgICAgICAgICAvL1NlbGVjdCB0aGUgdmlkZW8gc25pcHBldCB0byBkaXJlY3QgdW50by5cclxuICAgICAgICAgICAgICAgICAgICBiaHZzW1widmlkZW9fc25pcHBldFwiXSA9ICh7dXJsOiB2YWx1YWJsZVZpZGVvVXJsKHVybCwgYmh2SXRtLnZpZGVvX3NuaXBwZXQpfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy9FeHRyYWN0IHRoZSBxdWVyaWVzIGFuZCB0aXRsZSB0aGF0IG1heSBiZSB1c2VkIGZvciBtYXRjaGluZy5cclxuICAgICAgICAgICAgICAgIC8vQSBsaXN0IG9mIGFzc29jaWF0ZWQgcXVlcnkgZm9yIHRoaXMgY29kZSBzbmlwcGV0LiBUaGUgcXVlcmllc1xyXG4gICAgICAgICAgICAgICAgLy9pbiB0aGlzIGFycmF5IG11c3QgbWF0Y2ggdGhlIGN1cnJlbnQgb21uaWJveCBpbnB1dC5cclxuICAgICAgICAgICAgICAgIGxldCBxdWVyaWVzID0gW107XHJcbiAgICAgICAgICAgICAgICAvL0NoZWNrIGlmIHRoaXMgdXJsLCBhbmQgaGVuY2UgdGhpcyBiZWhhdmlvciwgaXNcclxuICAgICAgICAgICAgICAgIC8vYXNzb2NpYXRlZCB3aXRoIGEgcXVlcnkuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpZHggaW4gYmh2SXRtLnZpc2l0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZpc2l0ID0gYmh2SXRtLnZpc2l0W2lkeF07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZpc2l0W1wicXVlcnlcIl0gIT09IG51bGwgJiYgcXVlcnkudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKG9tbmlib3hUZXh0LnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJpZXMucHVzaCh2aXNpdFtcInF1ZXJ5XCJdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZWFjaF90eXBlIGluIGJodnMpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgYmVoYXZpb3JzID0gYmh2c1tlYWNoX3R5cGVdO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vRGV0ZXJtaW5lIGZvciBlYWNoIGJlaGF2aW9yIG9mIHRoaXMgdHlwZSBpZiBpdCBtYXRjaGVzXHJcbiAgICAgICAgICAgICAgICAgICAgLy90aGUgY3VycmVudCBpbnB1dCBnaXZlbiBieSB0aGUgdXNlci5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBiaHZJbmRleCBpbiBiZWhhdmlvcnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGJodiA9IGJlaGF2aW9yc1tiaHZJbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vVGhlIHNwZWNpZmljIHR5cGUgb2YgYmVoYXZpb3IgdGhlIGlucHV0IHRyaWdnZXJzLiBUaGlzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vbWF5IG1vZGlmeSB0aGUgYmVoYXZpb3IgdHlwZSBzdG9yZWQgdG8gb25lIG1vcmUgc3BlY2lmaWMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vbGlrZSBjb3B5IHRvIGNvZGUuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihiZWhhdmlvck1hdGNoZXNJbnB1dChlYWNoX3R5cGUsIGJodiwgb21uaWJveFRleHQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCBxdWVyaWVzLmxlbmd0aCAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJSZWFkeSB0byBTdG9yZSFcIik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHNuaXBwZXQgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ0aXRsZVwiOiBiaHZJdG0udGl0bGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ1cmxcIjogdXJsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwicXVlcnlcIjogcXVlcmllc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1N0b3JlIHRoaXMgYmVoYXZpb3IgYWNjb3JkaW5nbHkuIEZpcnN0IHNwZWNpZmljYWxseSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdGhlbiBhZGQgdGhlIGNvbW1vbiBhdHRyaWJ1dGVzLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmVTdWdnZXN0aW9uU25pcHBldChlYWNoX3R5cGUsIGJodiwgc25pcHBldCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9BZGQgdGhpcyBzbmlwcGV0IGZvciBzdWdnZXN0aW9uLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VnZ2VzdGlvbkhvbGRlci5wdXNoKHNuaXBwZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBtYWtlU3VnZ2VzdGlvbkhUTUwoc3VnZ2VzdCk7XHJcbiAgICAgICAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBAcGFyYW0gdGV4dFxyXG4gKiBAcGFyYW0gZGlzcG9zaXRpb25cclxuICovXHJcbmZ1bmN0aW9uIGFjY2VwdElucHV0KHRleHQsIGRpc3Bvc2l0aW9uKSB7XHJcbiAgICAvLyBkaXNwb3NpdGlvbjogXCJjdXJyZW50VGFiXCIsIFwibmV3Rm9yZWdyb3VuZFRhYlwiLCBvciBcIm5ld0JhY2tncm91bmRUYWJcIlxyXG4gICAgLy9JZiBwcmV2aW91c2x5IGV4dHJhY3RlZCBjb2RlIHNlZ21lbnRzIG1hdGNoIHRoZSBjdXJyZW50IHRleHQsIGRpcmVjdCB0byB0aGVtLlxyXG4gICAgaWYgKCFpc1ZhbGlkVXJsKHRleHQpICYmICFzdWdnZXN0aW9uSG9sZGVyKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgc3dpdGNoIChkaXNwb3NpdGlvbikge1xyXG4gICAgICAgIGNhc2UgXCJjdXJyZW50VGFiXCI6IHtcclxuICAgICAgICAgICAgLy9EZWZhdWx0IGxpbmsgdXNpbmcgdGV4dC5cclxuICAgICAgICAgICAgbGV0IGxpbmsgPSB0ZXh0O1xyXG5cclxuICAgICAgICAgICAgZm9yKGxldCBpbmRleCBpbiBzdWdnZXN0aW9uSG9sZGVyKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvL1NuaXBwZXQgb2YgdGl0bGUtYnVuZGxlZCBjb3BpZWQgYmVoYXZpb3IuXHJcbiAgICAgICAgICAgICAgICBsZXQgc25pcHBldCA9IHN1Z2dlc3Rpb25Ib2xkZXJbaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coc25pcHBldCk7XHJcbiAgICAgICAgICAgICAgICBpZihzbmlwcGV0LmNvbnRlbnQudHJpbSgpID09PSB0ZXh0KVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGxpbmsgPSBzbmlwcGV0LnVybDtcclxuICAgICAgICAgICAgICAgICAgICBsaW5rID0gc25pcHBldC51cmwuY29uY2F0KHNuaXBwZXQuc2VjdGlvbl9pZD9cclxuICAgICAgICAgICAgICAgICAgICAgICAgKFwiI1wiK3NuaXBwZXQuc2VjdGlvbl9pZCk6XCJcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJsaW5rIFwiLCBsaW5rKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjaHJvbWUudGFicy51cGRhdGUoe3VybDogbGlua30pO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSBcIm5ld0ZvcmVncm91bmRUYWJcIjoge1xyXG4gICAgICAgICAgICBjaHJvbWUudGFicy5jcmVhdGUoe3VybDogdGV4dH0pO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSBcIm5ld0JhY2tncm91bmRUYWJcIjoge1xyXG4gICAgICAgICAgICBjaHJvbWUudGFicy5jcmVhdGUoe3VybDogdGV4dCwgYWN0aXZlOiBmYWxzZX0pO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/js/background.js\n");

/***/ })

})